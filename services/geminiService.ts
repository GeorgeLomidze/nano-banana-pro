import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import { GenerationConfig, VideoGenerationConfig } from "../types";

export class GeminiService {
  /**
   * Always create a new instance right before making an API call to ensure it always uses the most up-to-date API key.
   */
  private static getAI() {
    return new GoogleGenAI({ apiKey: process.env.API_KEY as string });
  }

  static async generateImage(config: GenerationConfig, referenceImages?: string[]) {
    const ai = this.getAI();
    // gemini-3-pro-image-preview is mandatory for high-quality and search-enabled tasks.
    const modelName = 'gemini-3-pro-image-preview';

    const parts: any[] = [{ text: config.prompt }];
    
    if (config.negativePrompt) {
      parts.push({ text: `Avoid generating these elements: ${config.negativePrompt}` });
    }

    // Add all reference images
    if (referenceImages && referenceImages.length > 0) {
      for (const referenceImage of referenceImages) {
        const base64Data = referenceImage.split(',')[1];
        const mimeType = referenceImage.match(/data:(.*?);/)?.[1] || 'image/png';
        parts.push({
          inlineData: {
            data: base64Data,
            mimeType: mimeType
          }
        });
      }
    }

    const response = await ai.models.generateContent({
      model: modelName,
      contents: { parts },
      config: {
        imageConfig: {
          aspectRatio: config.aspectRatio,
          imageSize: config.imageSize
        }
      }
    });

    let imageUrl = '';
    // Find the image part, do not assume it is the first part.
    if (response.candidates?.[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          imageUrl = `data:image/png;base64,${part.inlineData.data}`;
          break;
        }
      }
    }

    if (!imageUrl) throw new Error("No image was generated by the model.");
    return imageUrl;
  }

  static async generateVideo(
    config: VideoGenerationConfig, 
    firstFrame?: string, 
    lastFrame?: string
  ): Promise<string> {
    const ai = this.getAI();
    // Use fast model for 'fast' speed, normal model for 'normal' speed
    const modelName = config.generationSpeed === 'fast' 
      ? 'veo-3.1-generate-preview' 
      : 'veo-3.1-generate-preview';

    // Build the prompt
    let fullPrompt = config.prompt;
    if (config.negativePrompt) {
      fullPrompt += ` Avoid: ${config.negativePrompt}`;
    }


    // Prepare image-to-video input if provided
    let imageParam: any = undefined;
    if (firstFrame) {
      const base64Data = firstFrame.split(',')[1];
      const mimeType = firstFrame.match(/data:(.*?);/)?.[1] || 'image/png';
      imageParam = {
        imageBytes: base64Data,
        mimeType: mimeType
      };
    }


    // Generate video using Veo 3.1
    const generateConfig: any = {
      aspectRatio: config.aspectRatio,
      numberOfVideos: 1,
      durationSeconds: 8,
    };

    let operation;
    if (imageParam) {
      operation = await ai.models.generateVideos({
        model: modelName,
        prompt: fullPrompt,
        image: imageParam,
        config: generateConfig
      });
    } else {
      operation = await ai.models.generateVideos({
        model: modelName,
        prompt: fullPrompt,
        config: generateConfig
      });
    }

    // Poll for completion using the correct method
    while (!operation.done) {
      await new Promise(resolve => setTimeout(resolve, 10000));
      operation = await ai.operations.getVideosOperation({
        operation: operation,
      });
    }

    // Check for content filtering first
    if (operation.response?.raiMediaFilteredCount && operation.response.raiMediaFilteredCount > 0) {
      const reasons = operation.response.raiMediaFilteredReasons;
      if (reasons && reasons.length > 0) {
        throw new Error(reasons[0]);
      }
      throw new Error("Video was blocked by content safety filters. Please try a different prompt or image.");
    }

    // Get the video
    if (operation.response?.generatedVideos && operation.response.generatedVideos.length > 0) {
      const video = operation.response.generatedVideos[0];
      if (video.video) {
        // Log what we got back
        console.log("Video response:", JSON.stringify(video.video, null, 2));
        
        // Download the video with API key authentication
        if (video.video.uri) {
          const apiKey = process.env.API_KEY as string;
          const downloadUrl = `${video.video.uri}&key=${apiKey}`;
          
          try {
            console.log("Downloading video from:", downloadUrl);
            const response = await fetch(downloadUrl);
            if (!response.ok) {
              console.error(`Failed to download video: ${response.status} ${response.statusText}`);
              throw new Error(`Failed to download video: ${response.status} ${response.statusText}`);
            }
            
            const contentType = response.headers.get('content-type');
            console.log("Video content type:", contentType);
            
            const blob = await response.blob();
            console.log("Video blob size:", blob.size, "type:", blob.type);
            
            // Create blob with explicit video MIME type if not set
            const videoBlob = blob.type ? blob : new Blob([blob], { type: 'video/mp4' });
            const blobUrl = URL.createObjectURL(videoBlob);
            console.log("Created blob URL:", blobUrl);
            
            return blobUrl;
          } catch (err: any) {
            console.error("Video download error:", err);
            throw new Error(`Video download failed: ${err.message}`);
          }
        } else {
          console.error("No video URI in response");
          throw new Error("No video URI in response");
        }
      } else {
        console.error("No video object in response");
        throw new Error("No video object in response");
      }
    }

    console.error("No videos in response. Full operation:", JSON.stringify(operation, null, 2));
    throw new Error("No video was generated by the model.");
  }
}